name: Flutter Build and Release on Main Branch Update

on:
  push:
    branches: [ main ]

jobs:
  build_and_release_on_main:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      # Checks out the repository code.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Sets up the Flutter environment.
      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.29.3' # Specify your project's Flutter version
          channel: 'stable'

      # Creates a dummy .env file for CI analysis and testing.
      - name: Create dummy .env file for analysis and testing
        run: |
          echo "API_BASE_URL=http://dummy.api.for.ci" > .env

      # Installs Flutter project dependencies.
      - name: Install dependencies
        run: flutter pub get

      # Analyzes the Flutter project for potential issues.
      - name: Analyze project
        run: flutter analyze

      # Runs all tests in the Flutter project.
      - name: Run tests
        run: flutter test

      # Reads the semantic version from pubspec.yaml.
      - name: Read pubspec.yaml semantic version
        id: pubspec
        run: |
          VERSION_LINE=$(grep '^version:' pubspec.yaml)
          SEMANTIC_VERSION=$(echo "$VERSION_LINE" | sed 's/version: //g' | sed 's/+\.*//g' | tr -d '[:space:]')
          echo "semantic_version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT

      # Creates the .env file with the actual API base URL for the release build.
      - name: Create .env file for Release Build
        run: |
          echo "API_BASE_URL=${{ secrets.API_BASE_URL }}" > .env
        env:
          API_BASE_URL: ${{ secrets.API_BASE_URL }} # Ensure this secret is configured

      # Builds the release APKs, split by ABI.
      - name: Build Release APKs (Split per ABI)
        run: flutter build apk --release --split-per-abi --build-name=${{ steps.pubspec.outputs.semantic_version }} --build-number=${{ github.run_number }}

      # Builds the debug APK.
      - name: Build Debug APK
        run: flutter build apk --debug

      # Renames the debug APK for consistent release naming.
      - name: Rename Debug APK for Release
        id: debug_apk_details
        run: |
          original_debug_apk_path="build/app/outputs/flutter-apk/app-debug.apk"
          new_debug_apk_name="app-debug-v${{ steps.pubspec.outputs.semantic_version }}+${{ github.run_number }}.apk"
          new_debug_apk_path="build/app/outputs/flutter-apk/${new_debug_apk_name}"
          if [ -f "$original_debug_apk_path" ]; then
            mv "$original_debug_apk_path" "$new_debug_apk_path"
            echo "path=$new_debug_apk_path" >> $GITHUB_OUTPUT
            echo "name=$new_debug_apk_name" >> $GITHUB_OUTPUT
          else
            echo "Debug APK not found, skipping rename."
            echo "path=" >> $GITHUB_OUTPUT
            echo "name=" >> $GITHUB_OUTPUT
          fi

      # Creates the release tag name based on semantic version and run number.
      - name: Create Release Tag Name
        id: create_tag
        run: |
          TAG_NAME="v${{ steps.pubspec.outputs.semantic_version }}+${{ github.run_number }}"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      # Prepares the release body content, including PR details if applicable.
      - name: Prepare Release Body
        id: prep_release_body
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { COMMIT_SHA, ACTOR, SEMANTIC_VERSION, RUN_NUMBER, REPO_URL, HEAD_COMMIT_MESSAGE } = process.env;
            let main_release_content = "";
            let pr_details_for_footer = "";
            const pr_regex_merge = /Merge pull request #(\d+)/;
            const pr_regex_squash_title = /\(#(\d+)\)(?:$|\n)/;
            let match = HEAD_COMMIT_MESSAGE.match(pr_regex_merge);
            if (!match) {
              const first_line_of_commit = HEAD_COMMIT_MESSAGE.split('\n')[0];
              match = first_line_of_commit.match(pr_regex_squash_title);
            }
            if (match && match[1]) {
              const pr_number = match[1];
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner, repo: context.repo.repo, pull_number: pr_number,
                });
                main_release_content = pr.body || "No description provided for this Pull Request.";
                pr_details_for_footer += `**Pull Request:** [#${pr_number}: ${pr.title}](${pr.html_url})\n`;
                pr_details_for_footer += `**PR Author:** @${pr.user.login}\n`;
              } catch (error) {
                core.warning(`Could not fetch PR #${pr_number} details: ${error.message}`);
                main_release_content = `Could not automatically fetch Pull Request description for PR #${pr_number}.\n\nAssociated PR: [#${pr_number}](${REPO_URL}/pull/${pr_number})\n`;
              }
            } else {
              const commit_title = HEAD_COMMIT_MESSAGE.split('\n')[0];
              let commit_body_part = HEAD_COMMIT_MESSAGE.substring(commit_title.length).trim();
              main_release_content = commit_body_part ? `**${commit_title}**\n\n${commit_body_part}` : HEAD_COMMIT_MESSAGE;
            }
            let footer_info = "\n\n---\n\n";
            footer_info += `**Version:** v${SEMANTIC_VERSION}+${RUN_NUMBER}\n`;
            footer_info += `**Released by:** @${ACTOR}\n`;
            footer_info += pr_details_for_footer;
            footer_info += `**Commit:** [${COMMIT_SHA.substring(0,7)}](${REPO_URL}/commit/${COMMIT_SHA})\n`;
            footer_info += `\n**Full Commit Message:**\n\`\`\`\n${HEAD_COMMIT_MESSAGE}\n\`\`\`\n`;
            core.setOutput("body", main_release_content + footer_info);
        env:
          SEMANTIC_VERSION: ${{ steps.pubspec.outputs.semantic_version }}
          RUN_NUMBER: ${{ github.run_number }}
          COMMIT_SHA: ${{ github.sha }}
          ACTOR: ${{ github.actor }}
          REPO_URL: ${{ github.server_url }}/${{ github.repository }}
          HEAD_COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

      # Creates a new GitHub release.
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.create_tag.outputs.tag_name }}
          release_name: "Release v${{ steps.pubspec.outputs.semantic_version }}+${{ github.run_number }}"
          body: ${{ steps.prep_release_body.outputs.body }}
          draft: false
          prerelease: false

      # Uploads the ABI-specific release APKs as assets to the GitHub Release.
      - name: Upload ABI-specific Release APK Assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          APK_DIR="build/app/outputs/flutter-apk"
          VERSION_TAG="v${{ steps.pubspec.outputs.semantic_version }}+${{ github.run_number }}"
          # Upload each ABI-specific and the universal release APK
          for apk_file in $APK_DIR/app-*-release.apk $APK_DIR/app-release.apk; do
            if [ -f "$apk_file" ]; then
              # Construct a unique name to avoid collision if app-release.apk is also an ABI (e.g. universal)
              # For app-arm64-v8a-release.apk -> app-arm64-v8a-release-vX.Y.Z+B.apk
              # For app-release.apk -> app-universal-release-vX.Y.Z+B.apk (assuming it's universal)
              base_name=$(basename "$apk_file" .apk)
              if [[ "$base_name" == "app-release" ]]; then
                asset_name="app-universal-release-$VERSION_TAG.apk"
              else
                asset_name="${base_name}-$VERSION_TAG.apk"
              fi
              echo "Uploading $asset_name from $apk_file"
              gh release upload "${{ steps.create_tag.outputs.tag_name }}" "$apk_file" --name "$asset_name" --clobber
            fi
          done
        # Ensure GitHub CLI (gh) is available. It usually is on ubuntu-latest.

      # Uploads the debug APK as an asset to the GitHub Release.
      - name: Upload Debug APK Asset
        if: steps.debug_apk_details.outputs.path != ''
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.debug_apk_details.outputs.path }}
          asset_name: ${{ steps.debug_apk_details.outputs.name }}
          asset_content_type: application/vnd.android.package-archive

      # Uploads all release APKs as a build artifact.
      - name: Upload All Release APKs as Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-apks-v${{ steps.pubspec.outputs.semantic_version }}+${{ github.run_number }}
          path: |
            build/app/outputs/flutter-apk/*-release.apk
            build/app/outputs/flutter-apk/app-release.apk # Ensure universal is included if named this way
          if-no-files-found: warn # Don't fail if app-release.apk doesn't exist (e.g. only ABI splits)

      # Uploads the debug build artifact.
      - name: Upload Debug Build Artifact
        if: steps.debug_apk_details.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: debug-apk-v${{ steps.pubspec.outputs.semantic_version }}+${{ github.run_number }}
          path: ${{ steps.debug_apk_details.outputs.path }}
          if-no-files-found: warn
