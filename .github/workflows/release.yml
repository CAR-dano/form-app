name: Flutter Build and Release on Main Branch Update

on:
  push:
    branches: [ main ]

jobs:
  build_and_release_on_main:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      # Checks out the repository code with full history for release purposes.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Sets up the Flutter environment with a specific version and channel.
      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.38.4'
          channel: 'stable'
          cache: true

      # Cache pub dependencies for faster subsequent runs
      - name: Cache pub dependencies
        uses: actions/cache@v3
        with:
          path: |
            ${{ env.PUB_CACHE }}
            ~/.pub-cache
          key: ${{ runner.os }}-pub-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: |
            ${{ runner.os }}-pub-

      # Cache Gradle wrapper and dependencies for faster Android builds
      - name: Cache Gradle wrapper
        uses: actions/cache@v3
        with:
          path: ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-wrapper-

      - name: Cache Gradle dependencies
        uses: actions/cache@v3
        with:
          path: ~/.gradle/caches
          key: ${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-caches-

      # Note: Android NDK caching removed to prevent disk space issues (NDK is ~1-3GB)
      # GitHub runners already have NDK pre-installed, so caching is unnecessary
      # This saves ~7 minutes in cache post-processing time
      
      # Note: CMake cache removed due to permission issues with system directories
      # CMake is auto-installed by Android SDK during build when needed
      
      # Build Strategy: We build only arm64-v8a (64-bit ARM) to:
      # - Avoid CMake dependency (required by x86_64 builds)
      # - Cover 95%+ of modern Android devices (2017+)
      # - Reduce build time and APK size
      # - Simplify deployment (fewer APKs to manage)
      # Devices supported: All modern Android phones/tablets with 64-bit processors

      # Installs all project dependencies listed in pubspec.yaml.
      - name: Install dependencies
        run: flutter pub get

      # Extracts the semantic version from the pubspec.yaml file.
      - name: Extract version from pubspec.yaml
        id: pubspec
        run: |
          VERSION_LINE=$(grep '^version:' pubspec.yaml)
          # Extract semantic version (e.g., 2.0.0)
          SEMANTIC_VERSION=$(echo "$VERSION_LINE" | sed -E 's/version: ([0-9]+\.[0-9]+\.[0-9]+)(\+.*)?/\1/' | tr -d '[:space:]')
          
          # Always use GitHub run number as the full build number
          FULL_BUILD_NUMBER="${{ github.run_number }}"

          FULL_VERSION="${SEMANTIC_VERSION}+${FULL_BUILD_NUMBER}"

          echo "semantic_version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          echo "full_build_number=$FULL_BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "full_version=$FULL_VERSION" >> $GITHUB_OUTPUT
      
      # Creates an .env file with the API base URL for the release build.
      - name: Create .env file for Release Build
        run: |
          echo "API_BASE_URL=${{ secrets.API_BASE_URL }}" > .env
          echo "API_BASE_URL_DEBUG=${{ secrets.API_BASE_URL_DEBUG }}" >> .env
        env:
          API_BASE_URL: ${{ secrets.API_BASE_URL }}
          API_BASE_URL_DEBUG: ${{ secrets.API_BASE_URL_DEBUG }}

      # Decode Keystore and Create Properties
      - name: Decode Keystore and Create Properties
        run: |
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 --decode > android/app/key.jks
          echo "storePassword=${{ secrets.STORE_PASSWORD }}" > android/key.properties
          echo "keyPassword=${{ secrets.KEY_PASSWORD }}" >> android/key.properties
          echo "keyAlias=${{ secrets.KEY_ALIAS }}" >> android/key.properties
          echo "storeFile=app/key.jks" >> android/key.properties

      # Accepts Android SDK licenses automatically (non-interactive)
      - name: Accept Android SDK licenses
        run: yes | flutter doctor --android-licenses

      # Create google-services.json from secret
      - name: Create google-services.json
        run: echo "${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}" | base64 --decode > android/app/google-services.json
        env:
          GOOGLE_SERVICES_JSON_BASE64: ${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}

      # Builds arm64-v8a Release APK (covers 95%+ of modern Android devices)
      # Using --target-platform to avoid building x86_64 (which requires CMake)
      - name: Build arm64-v8a Release APK
        run: flutter build apk --target-platform android-arm64 --release --build-name=${{ steps.pubspec.outputs.semantic_version }} --build-number=${{ steps.pubspec.outputs.full_build_number }}

      # Renames the arm64-v8a release APK immediately after build (before universal build overwrites it)
      - name: Rename arm64-v8a Release APK
        id: arm64_v8a_release_apk_details
        run: |
          original_path="build/app/outputs/flutter-apk/app-release.apk"
          new_name="palapa_inspeksi-v${{ steps.pubspec.outputs.semantic_version }}-arm64-v8a-release.apk"
          new_path="build/app/outputs/flutter-apk/$new_name"
          mv "$original_path" "$new_path"
          echo "path=$new_path" >> $GITHUB_OUTPUT
          echo "name=$new_name" >> $GITHUB_OUTPUT

      # Builds a universal (fat) Release APK for testing purposes
      - name: Build Universal (Fat) Release APK
        run: flutter build apk --release --build-name=${{ steps.pubspec.outputs.semantic_version }} --build-number=${{ steps.pubspec.outputs.full_build_number }}

      # Renames the universal release APK to include version.
      - name: Rename Universal Release APK
        id: universal_release_apk_details
        run: |
          original_path="build/app/outputs/flutter-apk/app-release.apk"
          new_name="palapa_inspeksi-v${{ steps.pubspec.outputs.semantic_version }}-universal-release.apk"
          new_path="build/app/outputs/flutter-apk/$new_name"
          mv "$original_path" "$new_path"
          echo "path=$new_path" >> $GITHUB_OUTPUT
          echo "name=$new_name" >> $GITHUB_OUTPUT

      # Creates an .env file with the API base URL for the debug build.
      - name: Create .env file for Debug Build
        run: echo "API_BASE_URL_DEBUG=${{ secrets.API_BASE_URL_DEBUG }}" > .env
        env:
          API_BASE_URL_DEBUG: ${{ secrets.API_BASE_URL_DEBUG }}

      # Builds a debug APK.
      - name: Build Debug APK
        run: flutter build apk --debug --build-name=${{ steps.pubspec.outputs.semantic_version }} --build-number=${{ steps.pubspec.outputs.full_build_number }}

      # Renames the debug APK to include version only (no build number to allow replacement).
      - name: Rename Debug APK
        id: debug_apk_details
        run: |
          original_path="build/app/outputs/flutter-apk/app-debug.apk"
          new_name="palapa_inspeksi-v${{ steps.pubspec.outputs.semantic_version }}-debug.apk"
          new_path="build/app/outputs/flutter-apk/$new_name"
          mv "$original_path" "$new_path"
          echo "path=$new_path" >> $GITHUB_OUTPUT
          echo "name=$new_name" >> $GITHUB_OUTPUT

      # Creates a release tag name based on the semantic version and run number.
      - name: Create Release Tag Name
        id: create_tag
        run: |
          TAG_NAME="v${{ steps.pubspec.outputs.semantic_version }}"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      # Prepares the release body content, including PR details and commit information.
      - name: Prepare Release Body
        id: prep_release_body
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const {
              COMMIT_SHA, ACTOR, SEMANTIC_VERSION, REPO_URL, HEAD_COMMIT_MESSAGE, FULL_VERSION
            } = process.env;

            const isDependabot = ACTOR === 'dependabot[bot]' || HEAD_COMMIT_MESSAGE.startsWith('build(deps):');
            const tagName = `v${SEMANTIC_VERSION}`;

            // Helper function to get date in WIB (GMT+7)
            const getWIBDate = () => {
              const now = new Date();
              const wibOffset = 7 * 60;
              const wibTime = new Date(now.getTime() + (wibOffset - now.getTimezoneOffset()) * 60000);
              return wibTime.toISOString().split('T')[0];
            };

            // Extract PR number from commit message
            const pr_regex_merge = /Merge pull request #(\d+)/;
            const pr_regex_squash_title = /\(#(\d+)\)(?:$|\n)/;
            let match = HEAD_COMMIT_MESSAGE.match(pr_regex_merge);
            if (!match) {
              const first_line_of_commit = HEAD_COMMIT_MESSAGE.split('\n')[0];
              match = first_line_of_commit.match(pr_regex_squash_title);
            }

            // Try to fetch existing release
            let existingRelease = null;
            try {
              const { data } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName,
              });
              existingRelease = data;
              core.info(`Found existing release for ${tagName}`);
            } catch (error) {
              core.info(`No existing release found for ${tagName} - will create new one`);
            }

            let release_body = "";

            // Case 1: Release doesn't exist - create full release body with footer
            if (!existingRelease) {
              core.info("Creating new release with full body and footer");

              let main_content = "";
              let pr_details = "";

              // Try to get PR body
              if (match && match[1]) {
                const pr_number = match[1];
                try {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr_number,
                  });
                  main_content = pr.body || "No description provided for this Pull Request.";
                  pr_details += `**Pull Request:** [#${pr_number}: ${pr.title}](${pr.html_url})\n`;
                  pr_details += `**PR Author:** @${pr.user.login}\n`;
                } catch (error) {
                  core.warning(`Could not fetch PR #${pr_number}: ${error.message}`);
                  main_content = `Could not automatically fetch Pull Request description for PR #${pr_number}. Please refer to the PR or commit message directly.\n\n`;
                  main_content += `**Associated PR:** [#${pr_number}](${REPO_URL}/pull/${pr_number})\n\n`;
                  main_content += `**Commit Message:**\n${HEAD_COMMIT_MESSAGE}`;
                }
              } else {
                // No PR found, use commit message
                main_content = HEAD_COMMIT_MESSAGE;
              }

              // Add footer
              let footer = "\n\n---\n\n";
              footer += `**Version:** v${FULL_VERSION}\n`;
              footer += `**Released by:** @${ACTOR}\n`;
              footer += pr_details;
              footer += `**Commit:** [${COMMIT_SHA.substring(0,7)}](${REPO_URL}/commit/${COMMIT_SHA})\n`;
              footer += `\n**Full Commit Message:**\n\`\`\`\n${HEAD_COMMIT_MESSAGE}\n\`\`\`\n`;

              release_body = main_content + footer;
            }
            // Case 2: Release exists + Dependabot - append dependency update
            else if (isDependabot) {
              core.info("Appending Dependabot update to existing release");

              release_body = existingRelease.body || "";

              // Extract PR number for the collapsible header link
              const pr_number = match ? match[1] : null;
              const pr_link = pr_number ? `[#${pr_number}](${REPO_URL}/pull/${pr_number})` : '';

              // Get current date in WIB
              const date = getWIBDate();

              // Parse dependencies from PR body table or commit message
              let dependencies_list = "";
              let package_count = 0;
              let pr_title = "Dependency update";

              if (pr_number) {
                try {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr_number,
                  });

                  pr_title = pr.title;
                  const prBody = pr.body || '';

                  // Try to parse dependency table from PR body
                  // Format: | Package | From | To |
                  const tableRegex = /\|\s*Package\s*\|\s*From\s*\|\s*To\s*\|[\s\S]*?\|[-\s|]+\|([\s\S]*?)(?=\n\n|$)/i;
                  const tableMatch = prBody.match(tableRegex);

                  if (tableMatch && tableMatch[1]) {
                    const rows = tableMatch[1].trim().split('\n');

                    for (const row of rows) {
                      // Match format: | [package](url) | `1.0.0` | `1.1.0` |
                      const cellMatch = row.match(/\|\s*\[([^\]]+)\]\(([^)]+)\)\s*\|\s*`([^`]+)`\s*\|\s*`([^`]+)`\s*\|/);
                      if (cellMatch) {
                        const [, packageName, packageUrl, fromVersion, toVersion] = cellMatch;
                        dependencies_list += `- [${packageName}](${packageUrl}): \`${fromVersion}\` -> \`${toVersion}\`\n`;
                        package_count++;
                      }
                    }
                  }

                  // Fallback: try to extract package count from commit message
                  if (package_count === 0) {
                    const updatesMatch = HEAD_COMMIT_MESSAGE.match(/with (\d+) update/);
                    if (updatesMatch) {
                      package_count = parseInt(updatesMatch[1]);
                      dependencies_list = `${package_count} package${package_count === 1 ? '' : 's'} updated (see [PR #${pr_number}](${REPO_URL}/pull/${pr_number}) for details)\n`;
                    }
                  }
                } catch (error) {
                  core.warning(`Could not fetch PR #${pr_number}: ${error.message}`);
                }
              }

              // Final fallback: Parse from commit message format "Bumps [package](url) from X to Y"
              if (package_count === 0) {
                const bump_regex = /Bumps \[(.*?)\]\((.*?)\) from ([\d.]+) to ([\d.]+)/g;
                let bump_match;
                while ((bump_match = bump_regex.exec(HEAD_COMMIT_MESSAGE)) !== null) {
                  const [, pkg_name, pkg_url, old_ver, new_ver] = bump_match;
                  dependencies_list += `- [${pkg_name}](${pkg_url}): \`${old_ver}\` -> \`${new_ver}\`\n`;
                  package_count++;
                }
              }

              // Ultimate fallback
              if (!dependencies_list) {
                const commit_title = HEAD_COMMIT_MESSAGE.split('\n')[0];
                dependencies_list = `${commit_title}\n`;
                package_count = 1;
              }

              // Create collapsible section
              let append_section = "\n\n";
              append_section += `<details>\n`;
              if (pr_number) {
                append_section += `<summary>${pr_title} #${pr_number}</summary>\n\n`;
              } else {
                append_section += `<summary>${pr_title}</summary>\n\n`;
              }

              if (package_count > 0 && !dependencies_list.includes('see PR')) {
                append_section += `**${package_count} package${package_count > 1 ? 's' : ''} updated:**\n\n`;
              }

              append_section += dependencies_list;
              append_section += `\n</details>`;

              release_body += append_section;
            }
            // Case 3: Release exists + Human - append PR update
            else {
              core.info("Appending human update to existing release");

              release_body = existingRelease.body || "";

              // Get current date in WIB
              const date = getWIBDate();

              // Get PR details
              let pr_title = "Update";
              let pr_body_content = HEAD_COMMIT_MESSAGE;
              const pr_number = match ? match[1] : null;
              const pr_link = pr_number ? `[#${pr_number}](${REPO_URL}/pull/${pr_number})` : '';

              if (pr_number) {
                try {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr_number,
                  });
                  pr_title = pr.title;
                  pr_body_content = pr.body || "No description provided.";
                } catch (error) {
                  core.warning(`Could not fetch PR #${pr_number}: ${error.message}`);
                  // Keep using HEAD_COMMIT_MESSAGE as fallback
                }
              }

              // Create collapsible section
              let append_section = "\n\n";
              append_section += `<details>\n`;
              if (pr_number) {
                append_section += `<summary>${pr_title} #${pr_number}</summary>\n\n`;
              } else {
                append_section += `<summary>${pr_title}</summary>\n\n`;
              }
              append_section += pr_body_content;
              append_section += `\n\n---\n\n`;
              append_section += `**Commit:** [${COMMIT_SHA.substring(0,7)}](${REPO_URL}/commit/${COMMIT_SHA})\n`;
              append_section += `**Released by:** @${ACTOR}\n`;
              append_section += `\n</details>`;

              release_body += append_section;
            }

            core.setOutput("body", release_body);
        env:
          SEMANTIC_VERSION: ${{ steps.pubspec.outputs.semantic_version }}
          COMMIT_SHA: ${{ github.sha }}
          ACTOR: ${{ github.actor }}
          REPO_URL: ${{ github.server_url }}/${{ github.repository }}
          HEAD_COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
          FULL_VERSION: ${{ steps.pubspec.outputs.full_version }}

      # Creates a new GitHub Release.
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.create_tag.outputs.tag_name }}
          name: "v${{ steps.pubspec.outputs.semantic_version }}"
          body: ${{ steps.prep_release_body.outputs.body }}
          draft: false
          prerelease: false
          files: |
            ${{ steps.universal_release_apk_details.outputs.path }}
            ${{ steps.arm64_v8a_release_apk_details.outputs.path }}
            ${{ steps.debug_apk_details.outputs.path }}

      # Uploads all release APKs as a build artifact.
      - name: Upload All Release APKs as Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-apks-v${{ steps.pubspec.outputs.semantic_version }}
          path: |
            ${{ steps.universal_release_apk_details.outputs.path }}
            ${{ steps.arm64_v8a_release_apk_details.outputs.path }}
          if-no-files-found: warn

      # Uploads the debug build artifact.
      - name: Upload Debug Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: debug-apk-v${{ steps.pubspec.outputs.semantic_version }}
          path: ${{ steps.debug_apk_details.outputs.path }}
